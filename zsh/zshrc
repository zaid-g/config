# Formatting notes for file
# 1. All variables declared inside functions must be local
# 2. internal function and alias names must always be uppercase and using underscore
# 3. shorthand functions/aliases must always be uppercase



# %% -------- [project creation and management brain] ----------:

function GENERATE_8_PRONOUNCEABLE_RANDOM_CHARS() {
    local length=${1:-8}
    local consonants="bcdfghjklmnpqrstvwxyz"
    local vowels="aeiou"
    local result=""
    local i
    # Seed RANDOM with current time to ensure uniqueness
    local RANDOM=$(date +%s%N | cut -b10-19)
    for ((i=0; i<length; i++)); do
        if ((i % 2 == 0)); then
            result+=${consonants:$((RANDOM % ${#consonants})):1}
        else
            result+=${vowels:$((RANDOM % ${#vowels})):1}
        fi
    done
    echo "$result"
}

function CREATE_TIMESTAMPED_DIR_AND_CD() {
    local base_dir="$1"
    shift
    local raw_folder_name="${*:-$(GENERATE_8_PRONOUNCEABLE_RANDOM_CHARS 8)}"
    local cleaned_folder_name=$(CLEAN_FILENAME "$raw_folder_name")
    local dir="${base_dir:+$base_dir/}${cleaned_folder_name}_$(date +%F_%H-%M-%S)"
    mkdir -p "$dir" && cd "$dir"
}

function MKJ() {
    CREATE_TIMESTAMPED_DIR_AND_CD ~/doc/junk "$@"
}

function MK() {
    CREATE_TIMESTAMPED_DIR_AND_CD "" "$@"
}

function MKD() {
    CREATE_TIMESTAMPED_DIR_AND_CD ~/Downloads "$@"
}

FIND_BRAIN_PARENT_PATH() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/brain" ]]; then
            echo "$dir"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    echo "No 'brain' directory found searching up to filesystem root" >&2
    return 1
}

FIND_BRAIN_PARENT_NAME() {
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    basename "$brain_parent_path"
}

function TB() {
    mkdir -p brain/junk brain/logs brain/ai
    touch brain/notes.txt brain/junk/junk.txt brain/related.txt brain/ai/ai.txt brain/tags.txt
}

function TH() {
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    mkdir -p "$brain_parent_path/brain"
    touch "$brain_parent_path/brain/command_history.txt"
}

function RH() {
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    rm -f "$brain_parent_path/brain/command_history.txt"
}

function WB() {
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    echo "$brain_parent_path/brain"
}

function WH() {
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    echo "$brain_parent_path/brain/command_history.txt"
}

function WN() {
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    echo "$brain_parent_path/brain/notes.txt"
}

function WJ() {
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    echo "$brain_parent_path/brain/junk/junk.txt"
}

function WAI() {
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    echo "$brain_parent_path/brain/ai.txt"
}

function WR() {
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    echo "$brain_parent_path/brain/related.txt"
}

function CH() {
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    cat "$brain_parent_path/brain/command_history.txt"
}

function CN() {
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    cat "$brain_parent_path/brain/notes.txt"
}

function CJ() {
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    cat "$brain_parent_path/brain/junk/junk.txt"
}

function CAI() {
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    cat "$brain_parent_path/brain/ai.txt"
}

function CRE() {
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    cat "$brain_parent_path/brain/related.txt"
}

function ARE() {
    if [[ $# -ne 1 ]]; then
        echo "Error: ARE requires exactly one argument (path)" >&2
        return 1
    fi
    
    if [[ ! -e "$1" ]]; then
        echo "Error: Path '$1' does not exist" >&2
        return 1
    fi
    
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    local full_path=$(readlink -f "$1")
    local temp_file=$(mktemp)
    
    # Add existing paths and new path to temp file, then sort unique
    if [[ -f "$brain_parent_path/brain/related.txt" ]]; then
        cat "$brain_parent_path/brain/related.txt" > "$temp_file"
    fi
    echo "$full_path" >> "$temp_file"
    
    # Remove duplicates and save back
    sort -u "$temp_file" > "$brain_parent_path/brain/related.txt"
    rm "$temp_file"
}

#  %% -------- [zsh hooks] ----------:

preexec() {
    CMD_START_EPOCH=$(date +%s)
    CMD_START_TIME=$(date '+%Y-%m-%d %H:%M:%S')
    local brain_parent_path=$(FIND_BRAIN_PARENT_PATH 2>/dev/null) || return
    [[ -f "$brain_parent_path/brain/command_history.txt" ]] || return
    local clean_cmd=$(echo "$3" | tr '\n\r' ' ')
    local lines=()
    while IFS= read -r line; do
        [[ "$line" != *$'\t\t\t'"$clean_cmd"$'\t\t\t'"$PWD" ]] && lines+=("$line")
    done < "$brain_parent_path/brain/command_history.txt"
    lines+=("$(date '+%Y-%m-%d %H:%M:%S')"$'\t\t\t'"$clean_cmd"$'\t\t\t'"$PWD")
    printf '%s\n' "${lines[@]}" | sort > "$brain_parent_path/brain/command_history.txt"
}

precmd() {
    if [[ -n $CMD_START_EPOCH ]]; then
        local end_epoch=$(date +%s)
        local delta=$((end_epoch - CMD_START_EPOCH))
        if [[ $delta -ge 10 ]]; then
            local end_time=$(date '+%Y-%m-%d %H:%M:%S')
            local duration=""
            if [[ $delta -ge 3600 ]]; then
                local hours=$((delta / 3600))
                local mins=$(((delta % 3600) / 60))
                local secs=$((delta % 60))
                duration="${hours}h ${mins}m ${secs}s"
            elif [[ $delta -ge 60 ]]; then
                local mins=$((delta / 60))
                local secs=$((delta % 60))
                duration="${mins}m ${secs}s"
            else
                duration="${delta}s"
            fi
            echo "\n - Time: $duration ($CMD_START_TIME → $end_time)\n"
        fi
        unset CMD_START_EPOCH
        unset CMD_START_TIME
    fi
}

function chpwd() {
    local leaf="${PWD:t}"
    [[ -z "$leaf" ]] && return  # Skip if at root or empty
    local env="$HOME/.virtualenvs/.$leaf"
    if [[ -d "$env" && "$VIRTUAL_ENV" != "$env" ]]; then
        [[ -n "$VIRTUAL_ENV" ]] && deactivate
        source "$env/bin/activate"
    fi
}

#  %% -------- [files folders path management] ----------:

alias CDC="cd ~/doc/config"
alias CDCC="cd ~/doc/config/config"
alias CDA="cd ~/doc"
alias CDD="cd ~/Downloads"
alias CD="cd ~/doc"
alias CDJ="cd ~/doc/junk"
alias CDT="cd ~/trash"

function CDB() {
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    cd "$brain_parent_path/brain"
}

function CDBP() {
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    cd "$brain_parent_path"
}

# get full path
alias FP='readlink -f'

# verbose mv
alias MVV="mv -v"

# ls
alias LL="ls -l --color=auto"
alias LLA="ls -lA --color=auto"
alias LLR="ls -ltr --color=auto"
alias LLD="LLR ~/Downloads"
alias LLT="LLR ~/trash"

function CLEAN_FILENAME() {
    echo -n "$1" | tr -d '*?[]|&;<>$`!"'"'"'(){}^~#\\' | tr ' \t\n' '___'
}

function PROCESS_DOWNLOAD_FILES_PATHS() {
    local prefix="" count=1
    if [[ "$1" =~ ^[0-9]+$ ]] && [[ -n "$2" ]]; then
        count="$1"; prefix="$2"
    elif [[ "$1" =~ ^[0-9]+$ ]]; then
        count="$1"
    elif [[ -n "$1" ]]; then
        prefix="$1"
    fi
    local files=$(ls -Art ~/Downloads 2>/dev/null | tail -n $count)
    [[ -z "$files" ]] && { echo "No files found" >&2; return 1; }
    echo "$files" | while IFS= read -r f; do
        local source_path="$HOME/Downloads/$f"
        local clean_filename=$(CLEAN_FILENAME "$f")
        local dest_filename="${prefix:+${prefix}_}$clean_filename"
        echo "$source_path|$dest_filename"
    done
}

# cp folders from local filesystem to local Downloads
function CPTOD() {
    [[ $# -eq 0 ]] && { echo "Usage: <command> <path>..."; return 1; }
    mkdir -p ~/Downloads
    for item in "$@"; do
        local resolved_path=$(readlink -f "$item")
        local cleaned_filename=$(CLEAN_FILENAME "$(basename "$resolved_path")")
        cp -rv "$item" ~/Downloads/"$cleaned_filename"
    done
}

# mv folders from local filesystem to local Downloads
function MVTOD() {
    [[ $# -eq 0 ]] && { echo "Usage: <command> <path>..."; return 1; }
    mkdir -p ~/Downloads
    for item in "$@"; do
        local resolved_path=$(readlink -f "$item")
        local cleaned_filename=$(CLEAN_FILENAME "$(basename "$resolved_path")")
        mv -v "$item" ~/Downloads/"$cleaned_filename"
    done
}

# mv folders from local filesystem to trash
function MVTOT() {
    [[ $# -eq 0 ]] && { echo "Usage: <command> <path>..."; return 1; }
    mkdir -p ~/trash
    for item in "$@"; do
        local resolved_path=$(readlink -f "$item")
        local cleaned_filename=$(CLEAN_FILENAME "$(basename "$resolved_path")")
        mv -v "$item" ~/trash/"$cleaned_filename"
    done
}

# cp folders from local Downloads to cwd in filesystem
function CP() {
    PROCESS_DOWNLOAD_FILES_PATHS "$@" | while IFS='|' read -r source dest; do
        cp "$source" "$dest" && printf "%s ->\n%s\n" "$source" "$(readlink -f "$dest")"
    done
}

# mv folders from local Downloads to cwd in filesystem
function MV() {
    PROCESS_DOWNLOAD_FILES_PATHS "$@" | while IFS='|' read -r source dest; do
        mv "$source" "$dest" && printf "%s ->\n%s\n" "$source" "$(readlink -f "$dest")"
    done
}

# upload Downloads content to remote
# (from local Downloads to remote Downloads)
function UDTOR() {
    ssh "$REMOTE" "mkdir -p ~/Downloads"
    PROCESS_DOWNLOAD_FILES_PATHS "$@" | while IFS='|' read -r source dest; do
        [ -f "$source" ] && rsync -avz "$source" "$REMOTE:~/Downloads/$dest"
    done
}

# upload local filesystem content to remote Downloads
function UTOR() {
    if [ $# -eq 0 ]; then
        echo "Usage: UTOR <path> [path2 ...]"
        return 1
    fi
    ssh "$REMOTE" "mkdir -p ~/Downloads"
    local full_paths=()
    for filepath in "$@"; do
        full_paths+=($(readlink -f "$filepath"))
    done
    rsync -avz "${full_paths[@]}" "$REMOTE:~/Downloads/"
}

# download from remote (remote filesystem to local Downloads)
function DFROMR() {
    local REMOTE_PATH
    if [ "$#" -ne 1 ]; then
        echo "Usage: DFR <remote_path>"
        return 1
    fi
    REMOTE_PATH=$1
    if [ -z "$REMOTE" ]; then
        echo "Error: REMOTE environment variable must be set"
        return 1
    fi
    local hostname=$(echo "$REMOTE" | cut -d'@' -f2 | cut -d'.' -f1)
    MKD "$hostname"
    if rsync -avz "$REMOTE:$REMOTE_PATH" ./; then
        chmod -R u+w .
        echo "✅ Downloaded to: $PWD"
        cd -
    else
        echo "❌ rsync failed for $REMOTE:$REMOTE_PATH"
        cd -
        return 1
    fi
}

# download from Remote's Downloads
# (remote Downloads to local Downloads)
function DFROMD() {
    if [ -z "$REMOTE" ]; then
        echo "Error: REMOTE environment variable must be set"
        return 1
    fi
    local latest=$(ssh "$REMOTE" "ls -Art ~/Downloads 2>/dev/null | tail -n 1")
    if [ -z "$latest" ]; then
        echo "❌ No files found in remote Downloads"
        return 1
    fi
    if rsync -avz "$REMOTE:~/Downloads/$latest" ~/Downloads/; then
        chmod -R u+w ~/Downloads/"$latest"
        echo "✅ Downloaded to: ~/Downloads/$latest"
    else
        echo "❌ rsync failed for $REMOTE:~/Downloads/$latest"
        return 1
    fi
}

TARGZ () {
	local target_path="$1"
	[[ -z "$target_path" ]] && {
		echo "Usage: TARGZ <path>"
		return 1
	}
	[[ ! -e "$target_path" ]] && {
		echo "Error: '$target_path' does not exist"
		return 1
	}
	local full_path
	local file_name
	local full_path_output
	full_path="$(readlink -f "$target_path")"
	file_name="$(basename "$full_path")"
	full_path_output="$(dirname "$full_path")/${file_name}.tar.gz"
	tar -czf "$full_path_output" -C "$(dirname "$full_path")" "$file_name" && \
		mv "$full_path_output" "$PWD/"
}

UNTARGZ() {
  local archive_path="$1"
  [[ -z "$archive_path" ]] && { echo "Usage: UNTARGZ <archive.tar.gz>"; return 1; }
  [[ ! -f "$archive_path" ]] && { echo "Error: '$archive_path' does not exist or is not a file"; return 1; }
  local full_path
  full_path="$(readlink -f "$archive_path")"
  tar -xzf "$full_path" -C "$PWD"
}

#  %% -------- [find search grep] ----------:

IGNORED_FOLDERS_PATTERNS=("node_modules" "build" ".*" "bin" "dist")
export GNU_FIND=$(which find)
export GNU_GREP=$(which grep)

function FIND_ALL_NON_IGNORED_FILES() {
    local ignored_folder_patterns=("${IGNORED_FOLDERS_PATTERNS[@]}")
    local find_cmd=(find .)
    for pattern in "${ignored_folder_patterns[@]}"; do
        find_cmd+=(-path "*/$pattern" -prune -o)
    done
    find_cmd+=(-type f -print)
    "${find_cmd[@]}"
}

# Function to find files matching given extensions
function FIND_NON_IGNORED_FILES_MATCHING_TYPES() {
    local extensions=("$@")
    local files=$(FIND_ALL_NON_IGNORED_FILES)
    # If extensions are given, filter by them (case-insensitive)
    if [ "${#extensions[@]}" -gt 0 ]; then
        local pattern=$(IFS=\|; echo "${extensions[*]}" | sed 's/ /|/gI')
        echo "$files" | grep -Eiq "\.(${pattern})$" && echo "$files" | grep -Ei "\.(${pattern})$" | sort || return
    else
        echo "$files" | sort
    fi
}

# Function to find files matching a general pattern
function FIND_FILES_MATCHING_PATTERN() {
    local pattern="$1"
    local files=$(FIND_ALL_NON_IGNORED_FILES)
    # If a pattern is given, filter by it (case-insensitive)
    if [ -n "$pattern" ]; then
        echo "$files" | grep -Eiq "$pattern" && echo "$files" | grep -Ei "$pattern" | sort || return
    else
        echo "$files" | sort
    fi
}

function FINDT() {
    FIND_NON_IGNORED_FILES_MATCHING_TYPES "$@"
}

function FIND() {
    FIND_FILES_MATCHING_PATTERN "$@"
}

function GREP() {
    local file
    if [ "$#" -eq 1 ]; then
        local pattern="$1"
        local files=$(FIND_NON_IGNORED_FILES_MATCHING_TYPES)
    else
        local pattern="${@: -1}"
        local exts=("${@:1:$#-1}")
        local files=$(FIND_NON_IGNORED_FILES_MATCHING_TYPES "${exts[@]}")
    fi
    [ -z "$files" ] && return
    while IFS= read -r file; do
        "$GNU_GREP" -Hni -e "$pattern" "$file"
    done <<< "$files"
}

# find files matching pattern one layer deep
function FIND1() {
    ls -d --color=always -1 *"$@"* | sort -t_ -k2,3
}

# %% -------- [vi vim lazyvim neovim nvim vi mode vi-mode] ----------:

# zsh vi mode
bindkey -v
export KEYTIMEOUT=1

# override this on dev machine
export NVIM_APPNAME="nvim" # lazyvim
export NEOVIM_EDITOR="nvim"

# vim, VM taken
alias V="$NEOVIM_EDITOR"

function VP() {
    local files
    if [ "$#" -eq 0 ]; then
        files=($(FIND_NON_IGNORED_FILES_MATCHING_TYPES))  # All allowed files
    else
        files=($(FIND_NON_IGNORED_FILES_MATCHING_TYPES "$@"))  # Filtered by extensions
    fi
    if (( ${#files[@]} )); then
        $NEOVIM_EDITOR "${files[@]}"
    else
        echo "No matching files found outside forbidden folders."
    fi
}

function VBEMOL() {
    bemol --verbose --watch > /tmp/bemol.log 2>&1 &
    local bemol_pid=$!
    $NEOVIM_EDITOR "$@"
    kill $bemol_pid 2>/dev/null
}

function VS(){
    local git_branch=$(git branch --show-current)
    $NEOVIM_EDITOR -S .vim/$git_branch.vim
}

function VB() {
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    local original_dir="$PWD"
    cd "$brain_parent_path"
	$NEOVIM_EDITOR -c "lua vim.api.nvim_create_autocmd('CursorHold', {callback = function() vim.cmd('silent! wall') end})" brain/**/notes.txt brain/**/junk.txt brain/**/ai.txt brain/**/*.txt
    cd "$original_dir"
}

function VZ() { NVIM_APPNAME=nvim $NEOVIM_EDITOR ~/.zshrc; }

function VT() { NVIM_APPNAME=nvim $NEOVIM_EDITOR ~/.tmux.conf; }

function VNOTES() { NVIM_APPNAME=nvim $NEOVIM_EDITOR ~/doc/brain/notes.txt; }

function VJUNK() { NVIM_APPNAME=nvim $NEOVIM_EDITOR ~/doc/brain/junk/junk.txt; }

function VAI() { NVIM_APPNAME=nvim $NEOVIM_EDITOR ~/doc/brain/ai/ai.txt; }

function VD() {
    local files=($(PROCESS_DOWNLOAD_FILES_PATHS "$@" | cut -d'|' -f1))
    (( ${#files[@]} )) && $NEOVIM_EDITOR "${files[@]}"
}

# %% -------- [git] ----------:

alias G="git"
alias GS="git status --untracked-files=all"
alias GR="git restore"
alias GD="git diff"
alias GDNO="git diff --name-only"
alias GA="git add"
alias GC="git commit -m"
alias GCH="git checkout"
alias GM="git merge"
alias GF="git fetch"
alias GL="git log --graph --decorate --oneline"
alias GFO="git fetch origin"
alias GB="git branch --sort=-committerdate"
alias GPUSH="git push -u origin HEAD"
alias GPULL='git pull --rebase origin $(git rev-parse --abbrev-ref HEAD)'

function GI() {
    if [[ ! -d .git ]]; then
        git init
    else
        echo "Git repository already exists"
    fi
}

function GIG() {
    [[ -z "$1" ]] && { echo "Usage: GIG <path>"; return 1; }
    [[ ! -d .git ]] && { echo "Not a git repository"; return 1; }
    [[ ! -f .gitignore ]] && touch .gitignore
    grep -Fxq "$1" .gitignore || echo "$1" >> .gitignore
}

function GCN() {
  git add . && git commit -m "${1:-$(date '+%Y-%m-%d %H:%M:%S')}"
}

function GDBP() {
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    git -C "$brain_parent_path" diff
}

function GSBP() {
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    git -C "$brain_parent_path" status
}

function GCBP() {
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    git -C "$brain_parent_path" add . && git -C "$brain_parent_path" commit -m 'F'
}

function GDIFF() {
    git rev-parse --git-dir >/dev/null 2>&1 || { echo "Not a git repo"; return 1; }
    local tmpfile=$(mktemp) file
    git diff "$@" >> "$tmpfile"
    if [[ $# -eq 0 ]]; then
        git ls-files --others --exclude-standard | while read -r file; do
            git diff --no-index /dev/null "$file" >> "$tmpfile"
        done
    fi
    cat "$tmpfile" | delta --side-by-side --line-numbers
    rm "$tmpfile"
}

function GSQUASH() {
    if [[ $# -ne 2 ]]; then
        echo "Usage: GSQUASH <commit_hash> <commit_message>"
        return 1
    fi
    local commit_hash="$1"
    local commit_message="$2"
    if ! git rev-parse --verify "$commit_hash" >/dev/null 2>&1; then
        echo "Error: Invalid commit hash"
        return 1
    fi
    git reset --soft "$commit_hash" && git commit -m "$commit_message"
}

function GSTASH() {
    local msg="${*:-"WIP stash"}"
    git stash push -u -m "$msg"
}

# %% -------- [python] ----------:

alias I="python3 -m IPython"
alias P="python3"
alias PT="python3 -m pytest -sxvv"
alias PTDB="pytest -sxvv --pdb"
alias BLACK="python3 -m black **/*.py"
alias PC="pre-commit run -a"

function PIP3(){
    pip3 install wheel
    pip3 install ipdb==0.13.11
    pip3 install ipython==7.31.1
    pip3 install neovim
    pip3 install pandas
    pip3 install black
}

function PVENV(){
    local current_working_directory=$(pwd)
    local project_name="$(basename $(pwd))"
    deactivate
    if [ -d ~/.virtualenvs/.$project_name ]; then
        rm -rf ~/.virtualenvs/.$project_name
    fi
    mkdir -p .vim
    mkdir -p ~/.virtualenvs
    builtin cd ~/.virtualenvs
    if [ "$#" -eq 0 ]; then
        python3 -m venv ".$project_name"
    else
        $1 -m venv ".$project_name"
    fi
    . ./".$project_name"/bin/activate
    builtin cd $current_working_directory
    touch requirements.txt
    touch Dockerfile
    if ! [ -e .git ]; then
        git init
        wget https://raw.githubusercontent.com/github/gitignore/main/Python.gitignore
        wget https://raw.githubusercontent.com/pre-commit/pre-commit/main/.pre-commit-config.yaml
        mv Python.gitignore .gitignore
        echo "\n# vim\n.vim\n.ccls*" >> .gitignore
    fi;
    PIP3 # keep at end
}

# %% -------- [tmux] ----------:

alias T='DISPLAY_COLOR=$DISPLAY_COLOR tmux -2'
alias TLS="tmux ls"
alias TAS="tmux attach-session -t"
alias TKS="tmux kill-session -t"
alias TKAS="tmux kill-server"

function TS() {
    builtin cd ~
    DISPLAY_COLOR="$DISPLAY_COLOR" tmux new-session -d
    local SESSION=$(tmux display-message -p '#S')

    # "doc" (horizontal split)
    tmux rename-window -t $SESSION:0 'notes'
    tmux split-window -h -t $SESSION:0
    tmux send-keys -t $SESSION:0.0 'CD' C-m
    tmux send-keys -t $SESSION:0.1 'VNOTES' C-m

    # "junk" (horizontal split)
    tmux new-window -t $SESSION: -n 'junk'
    tmux split-window -h -t $SESSION:1
    tmux send-keys -t $SESSION:1.0 'CDJ' C-m
    tmux send-keys -t $SESSION:1.1 'VJUNK' C-m

    # "ai" (horizontal split)
    tmux new-window -t $SESSION: -n 'ai'
    tmux split-window -h -t $SESSION:2
    tmux send-keys -t $SESSION:2.0 'KK' C-m
    tmux send-keys -t $SESSION:2.1 'VAI' C-m

    # "config" (horizontal split)
    tmux new-window -t $SESSION: -n 'config'
    tmux split-window -h -t $SESSION:3
    tmux send-keys -t $SESSION:3.0 'CDC' C-m
    tmux send-keys -t $SESSION:3.1 'CDCC' C-m

    tmux attach-session -t $SESSION:0
}

function TMUX_RENAME_WINDOW() {
    local window_name
    window_name=$(FIND_BRAIN_PARENT_NAME) || window_name=$(basename "$PWD")
    [[ ${#window_name} -gt 15 ]] && window_name="${window_name:0:12}…"
    tmux rename-window "$window_name"
}

# tmux open brain parent in new window
function TOBP() {
    local new_window=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -n|--new-window)
                new_window=true
                shift
                ;;
            *)
                echo "Unknown option: $1" >&2
                return 1
                ;;
        esac
    done
    local brain_parent_name
    brain_parent_name=$(FIND_BRAIN_PARENT_NAME) || return 1
    local brain_parent_path
    brain_parent_path=$(FIND_BRAIN_PARENT_PATH) || return 1
    cd "$brain_parent_path"
    [[ $new_window == true ]] && tmux new-window
    TMUX_RENAME_WINDOW
    tmux split-window -h
    tmux split-window -v
    tmux send-keys -t 0 'KK' Enter
    tmux send-keys -t 1 'VB' Enter
}

#  %% -------- [AI] ----------:

alias KK="kiro-cli chat --trust-all-tools"
alias KKR="kiro-cli chat --trust-all-tools"
alias KKE="cd ~/empty && kiro-cli chat --trust-all-tools --resume"
alias KKER="cd ~/empty && kiro-cli chat --trust-all-tools --resume"

#  %% -------- [sleep management caff decaff] ----------:

alias CAFF='caffeinate -dimsu &'
alias DECAFF='pkill caffeinate && echo "Killed caffeinate process" || echo "No caffeinate process found"'
alias LIDCAFF='sudo pmset -a disablesleep 1'
alias LIDDECAFF='sudo pmset -a disablesleep 0'

# %% -------- [docker] ----------:

function DOCK(){
    sudo docker run -it -v $HOME/doc/config/config:/home/ubuntu/doc/config/config $@ main
}
function DOCKCWD(){
    sudo docker run -it -v $(pwd):$(pwd) -v $HOME/doc/config/config:/home/ubuntu/doc/config/config -w $(pwd) $@ main
}
alias D="docker"
alias DB="docker build"
alias DR="docker run"
alias DC="docker container"
alias DCE="docker container exec"
alias DI="docker image"

#  %% -------- [amazon brazil ADA] ----------:

# brazil
alias BB=brazil-build
alias BRC='brazil-recursive-cmd'
alias BRCAP="brazil ws clean && brazil-recursive-cmd --allPackages brazil-build"
alias BWS="brazil ws --sync --md"
alias BW='brazil ws'
alias BWU='brazil ws use -p'
alias BWR='brazil ws remove -p'
alias BWC='brazil ws create --root'
alias BBCR='brazil ws clean && brazil-build clean && brazil-build release'
alias BBC='brazil-build clean'
alias BWC='brazil ws clean'
alias BBR='brazil-build release'
alias BBDEPLOY="brazil-build cdk deploy --require-approval never"

alias MW="mwinit -o && q whoami"
alias KI="kinit -f"
alias CL="card local --runtimePort 8082"

function ADA() {
    local account_number=$1
    if [ -z "$account_number" ]; then
        echo "Error: Please provide an account number"
        echo "Usage: ada_creds <account_number>"
        return 1
    fi
    ada credentials update --account="$account_number" --provider=conduit --role=IibsAdminAccess-DO-NOT-DELETE --once
}
function ADAL() {
    local account_number=$1
    if [ -z "$account_number" ]; then
        echo "Error: Please provide an account number"
        echo "Usage: ada_creds <account_number>"
        return 1
    fi
    ada credentials update --account="$account_number" --provider=conduit --role=IibsAdminAccess-DO-NOT-DELETE
}

# %% -------- [config management] ----------:

alias AC="bash ~/doc/config/config/apply_config.sh"
function FAAC() {
  local was_in_config=false
  [[ $PWD == ~/doc/config/config* ]] && was_in_config=true
  (
    cd ~/doc/config && \
    (git clone git@github.com:zaid-g/config.git config.new || git clone https://github.com/zaid-g/config.git config.new) && \
    rm -rf config && \
    mv config.new config && \
    bash config/apply_config.sh
  )
  [[ $was_in_config == true ]] && cd ~/doc/config/config
}
alias RS="source ~/.zshrc && cd ."

#  %% -------- [unix archlinux linux] ----------:

alias S="sudo"
alias PO="systemctl poweroff"
alias PMU="sudo pacman -Syu"
alias X="xdg-open"
alias VM="virt-manager"
alias DISCORD="snap run discord"
alias FF="firefox"
alias CHROME="google-chrome-stable --ozone-platform=wayland"

function GRIM(){
    if [ "$#" -eq 1 ]; then
        grim -g "$(slurp)" ~/Downloads/screenshot-"$1"-"$(date +'%Y-%m-%dT%H:%M:%S').png"
    else
        grim -g "$(slurp)" ~/Downloads/screenshot"$(date +'%Y-%m-%dT%H:%M:%S').png"
    fi
}

# %% ---------- [zsh auto-completion] ----------:

autoload -U compinit
zmodload zsh/complist
compinit
# Include hidden files
_comp_options+=(globdots)
zstyle ':completion:*' menu select
bindkey -M menuselect '^[[Z' reverse-menu-complete

# 0 -- vanilla completion (abc => abc)
# 1 -- smart case completion (abc => Abc)
# 2 -- word flex completion (abc => A-big-Car)
# 3 -- full flex completion (abc => ABraCadabra)
zstyle ':completion:*' matcher-list '' \
    'm:{a-z\-}={A-Z\_}' \
    'r:[^[:alpha:]]||[[:alpha:]]=** r:|=* m:{a-z\-}={A-Z\_}' \
    'r:|?=** m:{a-z\-}={A-Z\_}'

# %% ---------- [colors and prompt display color DISPLAY_COLOR] ----------:

# 256 color codes:
# 28  = green
# 46  = bright green
# 51  = bright cyan
# 39  = bright blue
# 226 = bright yellow
# 201 = bright magenta
# 196 = bright red
# 208 = orange
# 141 = purple
# 250 = light gray
# 240 = dark gray
# 15  = white
# 0   = black
# for i in {0..255}; do
#     printf "\x1b[38;5;${i}mcolor%-5i\x1b[0m" $i
#     (( (i+1) % 8 == 0 )) && echo
# done
export DISPLAY_COLOR=28

function COLORS(){
	for i in {0..255}; do
		printf "\x1b[38;5;${i}mcolor%-5i\x1b[0m" $i
		(( (i+1) % 8 == 0 )) && echo
	done
}

setopt PROMPT_SUBST # expands PS1 single quote
export PS1='%F{$DISPLAY_COLOR}%~ ▶%f '
export zle_highlight=('paste:bg=168,fg=251', 'region:bg=168,fg=251')

# %% -------- [others] ----------:

# xdg open (open file from terminal with default app)
alias H="history 0"
# Bind Ctrl-space to clear-screen
bindkey '^@' clear-screen
